#pragma once

#include "planner/plannodes/abstract_plan_node.h"
#include "parser/expression/tuple_value_expression.h"
#include "execution/compiler/codegen.h"


namespace tpl::compiler {

/**
 * Generic Operator Translator
 * TODO(Amadou): Only a few operations need all of these methods at once (sorting, aggregations, hash joins).
 * Other operations need just a few of them. So we could add a default implementation.
 * For now, I am leaving it like this so that the compiler will force me to think about all methods.
 */
class OperatorTranslator {
 public:
  /**
   * Constructor
   * @param op operator to translate
   * @param pipeline current pipeline
   */
  OperatorTranslator(const terrier::planner::AbstractPlanNode * op, CodeGen* codegen)
      : op_(op), codegen_(codegen) {}

  /**
   * Destructor
   */
  virtual ~OperatorTranslator() = default;


  virtual void InitializeStructs(util::RegionVector<ast::Decl *> *decls) = 0;
  virtual void InitializeHelperFunctions(util::RegionVector<ast::Decl *> *decls) = 0;
  virtual void InitializeSetup(util::RegionVector<ast::Stmt *> *setup_stmts) = 0;
  virtual void InitializeTeardown(util::RegionVector<ast::Stmt *> *teardown_stmts) = 0;
  virtual void InitializeStateFields(util::RegionVector<ast::FieldDecl *> *state_fields) = 0;


  virtual void Produce(FunctionBuilder * builder) = 0;

  /**
   * Casts an operator to a given type
   * @tparam T type to cast to
   * @return the casted operator
   */
  template <typename T>
  const T &GetOperatorAs() const {
    return static_cast<const T &>(op_);
  }

  /**
   * @param prev_translator the previous translator
   */
  void SetPrevTranslator(OperatorTranslator * prev_translator) {
    prev_translator_ = prev_translator;
  }

  /**
   * Whether this operator materializes structs.
   * Currently, this is used to simplify the probe phase of hash joins. The right side of the join does not have
   * to materialize a tuple if the right child already materialized it.
   * But I suspect it can simplify sorters, and perhaps other things.
   * Currently, SeqScan, Agg, and Sort are the materializers.
   * Most operators should return false here.
   * @param is_ptr[out] whether the function outputs a pointer.
   */
  virtual bool IsMaterializer(bool * is_ptr) {
    *is_ptr = false;
    return false;
  }

  /**
   * Return the identifiers of the materialized tuple if this a materializer.
   * The first element is the identifer of the local variable.
   * The second element is the identifier of its type.
   * Most operators should not be materializers.
   */
  virtual std::pair<ast::Identifier*, ast::Identifier*> GetMaterializedTuple() {
    return {nullptr, nullptr};
  }

  virtual ast::Expr* GetOutput(uint32_t attr_idx) = 0;

  virtual ast::Expr* GetChildOutput(uint32_t child_idx, uint32_t attr_idx, terrier::type::TypeId type) = 0;

  /**
   * Used by operators when they need to generate a struct containing a child's output.
   * Also used by the output layer to materialize the output
   * @param fields where to append the fields
   * @param prefix of the field name
   */
  void GetChildOutputFields(util::RegionVector<ast::FieldDecl*> *fields, const std::string &prefix) {
    uint32_t attr_idx = 0;
    for (const auto & col: prev_translator_->op_->GetOutputSchema()->GetColumns()) {
      ast::Identifier field_name = codegen_->Context()->GetIdentifier(prefix + std::to_string(attr_idx));
      ast::Expr * type = codegen_->TplType(col.GetExpr()->GetReturnValueType());
      fields->emplace_back(codegen_->MakeField(field_name, type));
      attr_idx++;
    }
  }

 protected:
  /**
   * The plan node
   */
  const terrier::planner::AbstractPlanNode * op_;

  /**
  * The code generator to use
  */
  CodeGen * codegen_;

  /**
   * The previous operator translator.
   * We need this to access members of tuples generated by previous operations.
   */
  OperatorTranslator * prev_translator_{nullptr};
};

}  // namespace tpl::compiler
