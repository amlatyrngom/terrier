#pragma once

#include <vector>
#include "execution/util/region.h"
#include "execution/compiler/codegen.h"
#include "execution/compiler/function_builder.h"
#include "execution/compiler/operator/operator_translator.h"

namespace tpl::compiler {

/**
 * A single pipeline
 */
class Pipeline {
 public:
  /**
   * Constructor
   * @param codegen the code generator to use
   */
  explicit Pipeline(CodeGen * codegen) : codegen_(codegen) {}

  /**
   * Add an operator translator to the pipeline
   * @param translator translator to add
   * @param parallelism parallelism level
   */
  void Add(OperatorTranslator *translator) {
    pipeline_.push_back(translator);
  }

  /**
   * @return the pipelines' function id
   */
  ast::Identifier GetPipelineName() {
    return codegen_->Context()->GetIdentifier("pipeline" + std::to_string(pipeline_idx_));
  }

  /**
   * Generate the top level declarations of this pipeline
   * @param decls list of functions and structs
   * @param state_fields list of state fields
   * @param setup_stmts list of stmts for the setup function
   * @param teardown_stmts list of stmts for the teardown functiono
   */
  void Initialize(util::RegionVector<ast::Decl *> *decls, util::RegionVector<ast::FieldDecl *> *state_fields, util::RegionVector<ast::Stmt *> *setup_stmts, util::RegionVector<ast::Stmt *> *teardown_stmts) {
    OperatorTranslator * prev_translator = nullptr;
    for (const auto & translator: pipeline_) {
      translator->SetPrevTranslator(prev_translator);
      translator->InitializeStateFields(state_fields);
      translator->InitializeStructs(decls);
      translator->InitializeHelperFunctions(decls);
      translator->InitializeSetup(setup_stmts);
      translator->InitializeTeardown(teardown_stmts);
      prev_translator = translator;
    }
  }

  /**
   * Produce the code of this pipeline
   * @param pipeline_idx index of of this pipeline
   * @return the function generated by this pipeline
   */
  ast::Decl* Produce(uint32_t pipeline_idx) {
    pipeline_idx_ = pipeline_idx;
    // Function name
    ast::Identifier fn_name = GetPipelineName();

    // Function parameter
    util::RegionVector<ast::FieldDecl*> params = codegen_->ExecParams();

    // Function return type (nil)
    ast::Expr *ret_type = codegen_->BuiltinType(ast::BuiltinType::Kind::Nil);

    FunctionBuilder builder{codegen_, fn_name, std::move(params), ret_type};

    for (const auto & translator: pipeline_) {
      translator->Produce(&builder);
    }
    return builder.Finish();
  }

 private:
  CodeGen * codegen_;
  std::vector<OperatorTranslator *> pipeline_{};
  uint32_t pipeline_idx_{0};
};

}  // namespace tpl::compiler
